<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Project Euler Solutions</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="problems.html"><strong aria-hidden="true">2.</strong> Problems</a></li><li><ol class="section"><li><a href="p001.html"><strong aria-hidden="true">2.1.</strong> Problem 001</a></li><li><a href="p002.html"><strong aria-hidden="true">2.2.</strong> Problem 002</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Project Euler Solutions</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#project-euler-solutions" id="project-euler-solutions">Project Euler Solutions</a></h1>
<p>These are my coded solutions and explanations for problems from
<a href="https://projecteuler.net/">Project Euler</a>.</p>
<p>In each you will find a brute-force solution and steps to improve
it. The problems are inherently mathematical and the explanations for
the more optimal solutions necessitate delving into number theory. I
have tried to explain concepts from the ground up, though some
familiarity with mathematical notation will be useful.</p>
<p>Whilst every effort has been made to ensure the explanations are
accurate and correct, you are encouraged to raise an issue on the
<a href="https://github.com/kwyse/euler-solutions">source repository</a> if you
find a mistake. If you know the fix, a pull request would be even
better! Many thanks in advance.</p>
<h1><a class="header" href="#problems" id="problems">Problems</a></h1>
<p>These solutions are implemented in
<a href="https://www.rust-lang.org/">Rust</a>. Rust hits a sweet spot between
performant and expressive code. Benchmarks are included that
illustrate the solutions are optimised beyond a naive
implementation. It is my hope that you will find the code clear and
concise.</p>
<p>Benchmarks are performed by the
<a href="https://crates.io/crates/criterion">Criterion</a> library. Criterion
also generates the included reports and uses
<a href="http://www.gnuplot.info/">Gnuplot</a> under the hood to generate the
graphs.</p>
<p><a href="https://crates.io/crates/clippy">Clippy</a> is used to lint the
code. The build and deployment process is managed by <a href="https://travis-ci.org/">Travis
CI</a>. You can find the source for the project
in its <a href="https://github.com/kwyse/euler-solutions">repository on
GitHub</a>.</p>
<p>This book itself is generated with
<a href="https://rust-lang-nursery.github.io/mdBook/">mdBook</a> and hosted on
<a href="https://pages.github.com/">GitHub Pages</a>.</p>
<h1><a class="header" href="#problem-001" id="problem-001">Problem 001</a></h1>
<blockquote>
<p>If we list all the natural numbers below 10 that are multiples of 3
or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
</blockquote>
<p>We can solve this by iterating from one to one thousand, filtering out
numbers that are multiples of three or five, and summing the remaining
numbers. Let's implement something along those lines.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let result = (1..1_000)
        .filter(|n| [3, 5].iter().any(|m| n % m == 0))
        .sum::&lt;u32&gt;();

    println!(&quot;{}&quot;, result);
}
</code></pre></pre>
<p>Try it out. It runs in the order of microseconds with these
inputs. This implementation is simple, demonstrates the intention, and
runs in \( O(n) \) time with respect to the limit, which is \( 1000
\) here. However, we can improve the run time by about a thousand
times with some number theory.</p>
<h2><a class="header" href="#gauss-and-sequence-summation" id="gauss-and-sequence-summation">Gauss and Sequence Summation</a></h2>
<p>Guass' method of summing a sequence of numbers starting with \( 1 \)
doesn't rely on iteration.</p>
<p>\[ \sum_{i=1}^{n} i = \dfrac{n(n + 1)}{2} \tag{1}\label{1} \]</p>
<p>To see why this works, let's look at when \( n = 6\).</p>
<p>\[ \sum_{i=1}^{6} i = 1 + 2 + 3 + 4 + 5 + 6 \]</p>
<p>For each number \( x_i \) up to \( \frac{n}{2} \), pair it with
\( x_{n-i+1} \).</p>
<p>\[ 1 + 6 = 7 \]
\[ 2 + 5 = 7 \]
\[ 3 + 4 = 7 \]</p>
<p>We have \( \frac{n}{2} \) pairs and each pair is equal to \( 7 \),
or \( n + 1 \), hence our equation is \( \frac{n}{2} \cdot (n + 1)
\) and equivalent to equation \( \eqref{1} \).</p>
<p>If \( n \) is odd, we won't be able to pair all of the numbers
unless we include \( 0 \). Let's try this with \( n = 7 \).</p>
<p>\[ 0 + 7 = 7 \]
\[ 1 + 6 = 7 \]
\[ 2 + 5 = 7 \]
\[ 3 + 4 = 7 \]</p>
<p>Now we have \( \frac{n + 1}{2} \) pairs but they all equal \( n
\), so our equation is \( \frac{n + 1}{2} \cdot n \), which is also
equivalent to equation \( \eqref{1} \). So we have a way to sum a
sequence all of the numbers up a given \( n \), and we have a method
of intuitively understanding why it works. But what if we didn't have
the formula to begin with?</p>
<h2><a class="header" href="#recurrences-and-mathematical-induction" id="recurrences-and-mathematical-induction">Recurrences and Mathematical Induction</a></h2>
<p>We can start by defining the <em>recurrence relation</em> for the sequence.</p>
<p>\[
\begin{align}
\\ S_{0} &amp;= 0 \tag{2}\label{2}
\\ S_{n} &amp; = S_{n-1} + n,
\quad \text{for } n \in \mathbb{N}_1 \tag{3}\label{3}
\end{align}
\]</p>
<p>A recurrence relation is an equation or set of equations that express
each term of a sequence with respect to earlier terms, and often
include one or more <em>intial conditions</em>. Recurrence relations lead to
inherently recursive solutions. We can compute any \( S_{n} \), but
only by caclulating all of the previous values in the sequence. In
this instance, that would result in an \( O(n) \) runtime. The work
we have to do is effectively unbounded because it scales with \( n
\). It would be better to have a solution that has a known finite
amount of work to perform, called a <em>closed form solution</em>.</p>
<p>One method to find the closed form of a recurrence is to guess the
solution and then prove its correctness. We could start by looking at
the smaller cases of the sequence and trying to see the pattern of the
progression.</p>
<p>\[
0, 1, 3, 6, 10, 15 \quad = \quad \frac{0 \cdot 1}{2},
\frac{1 \cdot 2}{2}, \frac{2 \cdot 3}{2}, \frac{3 \cdot 4}{2},
\frac{4 \cdot 5}{2}, \frac{5 \cdot 6}{2}
\]</p>
<p>From that, we can define our <em>proposition</em>.</p>
<p>\[
S_{n} = \frac{n(n + 1)}{2},
\quad \text{for } n \in \mathbb{N}_0 \tag{4}\label{4}
\]</p>
<p>A proposition is the statement we wish to prove, and a method we can
use to prove it by is called <em>mathematical induction</em>. We define a
<em>basis</em>, \( n_0 \), that is the smallest value of \( n \), and
prove our proposition for \( n_0 \). We then define an <em>induction</em>,
where \( n &gt; n_0 \). Our earlier recurrence naturally fits into this
framework.</p>
<p>First, we prove the basis by substituting the value of equation \(
\eqref{2} \) into our proposition \( \eqref{4} \).</p>
<p>\[
\begin{align}
S_0 &amp; = \frac{0 \cdot (0 + 1)}{2} \\ &amp; = 0
\end{align}
\]</p>
<p>To prove the induction, we take our recurrence \( \eqref{3} \),
which we know to be correct, and substitute our proposition \(
\eqref{4} \) into it.</p>
<p>\[
\begin{align}
S_n &amp; = S_{n-1} + n \\ &amp; = \frac{(n - 1) \cdot ((n - 1) + 1)}{2} + n
\end{align}
\]</p>
<p>Our goal is to get back to the proposition \( \eqref{4} \) from the
equation with the substitution. Doing that is proof that our
proposition holds. We solve the equation algebraically.</p>
<p>\[
\begin{align}
\\ S_n &amp; = \frac{(n - 1) \cdot ((n - 1) + 1)}{2} + n
\\ &amp; = \frac{(n - 1) \cdot n}{2} + \frac{2n}{2}
\\ &amp; = \frac{n(n - 1) + 2n}{2}
\\ &amp; = \frac{n(n - 1 + 2)}{2}
\\ &amp; = \frac{n(n + 1)}{2}
\end{align}
\]</p>
<p>Success! We can now be confident that our closed form solution is
correct for all of the input values we care about.</p>
<h2><a class="header" href="#implementation" id="implementation">Implementation</a></h2>
<p>Our closed form solution has a finite amount of work to do regardless
of the input value \( n \), so its runtime is \( O(1) \). Let's
implement it.</p>
<pre><code class="language-rust noplaypen">fn sum_to(n: u32) -&gt; u32 {
    (n * (n + 1)) / 2
}
#
# assert_eq!(sum_to(0), 0);
# assert_eq!(sum_to(1), 1);
# assert_eq!(sum_to(2), 3);
# assert_eq!(sum_to(3), 6);
# assert_eq!(sum_to(4), 10);
# assert_eq!(sum_to(5), 15);
# assert_eq!(sum_to(6), 21);
# assert_eq!(sum_to(7), 28);
</code></pre>
<p>Since we're dividing by \( 2 \) here, you may think we can further
optimise this by performing a logical right shift by one place
instead. Doing so did not result in a change in performance when I
benchmarked it, likely because Rust's compiler already takes care of
simpler optimisations like this.</p>
<p>Now we can sum sequences like like \( 1 + 2 + 3 + 4 + 5 + \cdots + n
\), but our problem statement is asking for something
different. Instead of each term in our sequence incrementing by \( 1
\), we want it increment by an arbitrary amount \( x \) that
corresponds to the base of the multiples that we are summing. So for
\( x = 3 \), we want \( 3 + 6 + 9 + 12 + 15 \cdots + n \). This
should result in a lower answer, because we are including less terms
in the sequence. It's simply a matter of dividing our inner \( n \)
by \( x \) and taking the floor of this value.</p>
<p>\[
\sum_{i=1}^{\lfloor \frac{n}{x} \rfloor} xi
= \dfrac{n(\lfloor \frac{n}{x} \rfloor + 1)}{2} \tag{5}\label{5}
\]</p>
<p>So now we have the afformentioned multiples-of-three sequence and we
can calculate \( 5 + 10 + 15 + \cdots + n \). But as you can see
from looking at the sequences, we're including \( 15 \) twice, and
we would also include all of its multiples up to \( n \). \( 15 \)
is the product of all of the values in the input set, hence we must
subtract the sum of the multiples of the product of the input
set. This brings us to our solution.</p>
<pre><code class="language-rust noplaypen"># fn sum_to(n: u32) -&gt; u32 {
#     (n * (n + 1)) / 2
# }
#
pub fn sum_all_multiples(xs: &amp;[u32], n: u32) -&gt; u32 {
    let sum_multiples_for_x = |x| x * sum_to((n - 1) / x);

    let multiples = xs.iter().map(sum_multiples_for_x).sum::&lt;u32&gt;();
    let product_multiples = sum_multiples_for_x(&amp;xs.iter().product::&lt;u32&gt;());
    multiples - product_multiples
}
</code></pre>
<p>This solution allows us to generalise the problem statement.</p>
<blockquote>
<p>Given a set of numbers \( xs \), find the sum of all of the
multiples of these numbers that are under a limit \( n \).</p>
</blockquote>
<p>The solution shows another way to think about equation \( \eqref{5}
\). <code>sum_multiples_for_x</code> multiplies <code>sum_to</code> with the value of <code>x</code>
because the sum should be <code>x</code> times larger than the sum of sequence
where each term is one larger than the previous term. But because we
still only want to sum values up to <code>n</code>, we divide the value we pass
to <code>sum_to</code> by <code>x</code>.</p>
<p>This implementation runs in the order of nanoseconds.</p>
<p><img src="benchmarks/p001/report/pdf.svg" alt="PDF" /></p>
<p><a href="https://github.com/kwyse/euler-solutions/blob/master/src/p001.rs">Full source code</a></p>
<p><a href="benchmarks/p001/report/index.html">Benchmark report</a></p>
<h1><a class="header" href="#problem-002" id="problem-002">Problem 002</a></h1>
<blockquote>
<p>Each new term in the Fibonacci sequence is generated by adding the
previous two terms. By starting with 1 and 2, the first 10 terms
will be:</p>
<p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>
<p>By considering the terms in the Fibonacci sequence whose values do
not exceed four million, find the sum of the even-valued terms.</p>
</blockquote>
<p>Let's return to the practice we established in the <a href="p001.html">first
problem</a> and state our recurrence relation. We shall begin
the sequence from \( 0 \) instead of \( 1 \) to ensure that our
solution works for all natural numbers, though of course we're still
bound by the bit widths of our integer types.</p>
<p>\[
\begin{align}
\\ F_0 &amp;= 0
\\ F_1 &amp;= 1
\\ F_n &amp;= F_{n-1} + F_{n-2}
\end{align}
\]</p>
<p>A recursive Fibonacci implementation follows from this recurrence, and
from there it's simply a matter of calling this function with every
natural number, filtering out values that aren't even, stopping once
we've reached our limit value, and summing all the numbers we've
collected.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let result = (0..)
		.filter_map(|i| Some(fib(i)).filter(|n| n % 2 == 0))
		.take_while(|&amp;n| n &lt; 4_000_000)
		.sum::&lt;u32&gt;();

    println!(&quot;{}&quot;, result);
}

fn fib(n: u32) -&gt; u32 {
	match n {
		0 =&gt; 0,
		1 =&gt; 1,
		_ =&gt; fib(n - 1) + fib(n - 2),
	}
}
</code></pre></pre>
<p>Our Fibonacci algorithm is \( O(2^n) \), so we shouldn't expect our
runtime to be stellar. Profiling our implementation confirms this.</p>
<pre><code class="language-text">Lower bound:   192.39 ms
Best estimate: 192.49 ms
Upper bound:   192.60 ms
</code></pre>
<p>It could be worse, but there's definitely room for improvement.</p>
<h2><a class="header" href="#memoization" id="memoization">Memoization</a></h2>
<p>A clear understanding of why this Fibonacci algorithm is \( O(2^n)
\) will illustrate where we can make improvements. Consider what our
function calls would look like.</p>
<p>\[
\begin{align}
\\ F_n &amp;= F_{n-1} + F_{n-2}, \quad &amp;\text{2 terms, } 2^1
\\ &amp;= F_{n-2} + F_{n-3} + F_{n-3} + F_{n-4}, \quad &amp;\text{4 terms, } 2^2
\\ &amp;= F_{n-3} + F_{n-4} + F_{n-4} + F_{n-5} + F_{n-4}
+ F_{n-5} + F_{n-5} + F_{n-6}, \quad &amp;\text{8 terms, } 2^3
\end{align}
\]</p>
<p>Here, \( F_{n-3} \) is called twice on the second line, each time
calling \( F_{n-4} \), itself which may result in the same value
being called multiple times. Each one of these calls is a calculation
to perform, and it's currently being done repeatedly on the same
values.</p>
<p>This is the problem <em>memoization</em> solves. Memoization is an
optimisation technique. Whenever we calculate an intermediate value,
we cache it and enable it to be used later on. We can use a <code>HashMap</code>
for this purpose.</p>
<pre><code class="language-rust no_run noplaypen"># use std::collections::HashMap;
#
fn fib(n: u32, cache: &amp;mut HashMap&lt;u32, u32&gt;) -&gt; u32 {
    match cache.get(&amp;n) {
        Some(ret) =&gt; *ret,
        None =&gt; {
            let ret = match n {
	        0 =&gt; 0,
	        1 =&gt; 1,
	        _ =&gt; fib(n - 1, cache) + fib(n - 2, cache),
            };

            cache.insert(n, ret);
            ret
        }
    }
}
</code></pre>
<p>As expected, we see a dramatic performance increase.</p>
<pre><code class="language-text">Lower bound:   3.6219 us
Best estimate: 3.6337 us
Upper bound:   3.6463 us
</code></pre>
<h2><a class="header" href="#reducing-time-and-space" id="reducing-time-and-space">Reducing Time And Space</a></h2>
<p>We've reduced the <em>time</em> complexity of our Fibonacci algorithm down
from \( O(2^n) \) to \( O(n) \), but only at the expense of space
complexity. Whilst before we had space taken up by stack frames during
the recursion, it's now being taken up by the <code>HashMap</code> <em>in
addition</em>. Neither of these allocations are necessary.</p>
<p>Consider the fact that we don't need to calculate arbitrary terms in
the sequence. We only ever need to know the next term. To know the
next term, we only ever need to know the two previous terms. We could
instead create an iterative solution, removing the memory needed for
the stack frames during recursion, and only hold the previous two
values in memory at a given time, removing the need for the <code>HashMap</code>.</p>
<p>Going even further, consider that we only need the even terms. Let's
look to see if there's a pattern for when they occur.</p>
<p>\[ \mathbf{0}, 1, 1, \mathbf{2}, 3, 5, \mathbf{8}, 13, 21,
\mathbf{34}, 55, 89, \mathbf{144} \]</p>
<p>It appears that every third item of the sequence is even. We can prove
this with the laws of arithmetic.</p>
<p>\[ even + even = even \]
\[ odd + odd = even \]
\[ even + odd = odd \]</p>
<p>Given the first and second term is even and odd respectively, the
third term must be odd, and given that, the fourth term must be even,
and then the fifth term odd. The sequence is periodic in this respect
because it is based on previous values. If this property exists at the
start of the sequence, it exists for the entire sequence.</p>
<p>Return once again to our recurrence, and observe it can be written in
terms of every third term.</p>
<p>\[ F_n = F_{n-1} + F_{n-2} \]
\[ F_{3n} = F_{3n-1} + F_{3n-2} \]</p>
<p>If we could formulate the recurrence in terms of the \( n - 3 \) and
\( n - 6 \), we could reduce it to only care about every third term.</p>
<p>\[
\begin{align}
\\ F_{3n} &amp;= \color{blue}{F_{3n-1}} + F_{3n-2}
\\ &amp;= \color{blue}{F_{3n-2} + F_{3n - 3}} + F_{3n-2}
\\ &amp;= 2 \cdot \color{purple}{F_{3n-2}} + F_{3n - 3}
\\ &amp;= 2 \left(\color{purple}{F_{3n-3} + F_{3n - 4}}\right) + F_{3n-3}
\\ &amp;= 3 \cdot F_{3n-3} + F_{3n-4} + \color{green}{F_{3n-4}}
\\ &amp;= 3 \cdot F_{3n-3} + F_{3n-4} + \color{green}{F_{3n-5} + F_{3n-6}}
\\ &amp;= 3 \cdot F_{3n-3} + F_{3n-3} + F_{3n-6}
\\ &amp;= 4 \cdot F_{3n-3} + F_{3n-6}
\end{align}
\]</p>
<p>Now, if we divide our indices by \( 3 \), we have a recurrence that
yields the even-valued Fibonacci numbers.</p>
<p>\[ E_n = 4 \cdot E_{n-1} + E_{n-2} \]</p>
<h2><a class="header" href="#implementation-1" id="implementation-1">Implementation</a></h2>
<p>Let's create a data structure to hold the two values we need. By
implementing <code>Default</code>, we can seed our initial values, and by
implementing <code>Iterator</code>, we obtain the means to manipulate the
sequence as we please and this will simplify our solution to the
original problem.</p>
<pre><code class="language-rust no_run noplaypen">pub struct EvenFibIter {
    a: u32,
    b: u32,
}

impl Default for EvenFibIter {
    fn default() -&gt; Self {
        Self { a: 0, b: 2 }
    }
}

impl Iterator for EvenFibIter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let curr = self.a;
        self.a = self.b;
        self.b = 4 * self.a + curr;

        Some(curr)
    }
}
</code></pre>
<p>This solution has a time complexity of \( O(n) \) and a space
complexity of \( O(1) \). It is now simple to solve the problem.</p>
<pre><code class="language-rust no_run noplaypen">pub fn sum_of_even_value_fibs(limit: u32) -&gt; u32 {
    EvenFibIter::default().take_while(|&amp;n| n &lt; limit).sum()
}
#
# pub struct EvenFibIter {
#     a: u32,
#     b: u32,
# }
# 
# impl Default for EvenFibIter {
#     fn default() -&gt; Self {
#         Self { a: 0, b: 2 }
#     }
# }
# 
# impl Iterator for EvenFibIter {
#     type Item = u32;
# 
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         let curr = self.a;
#         self.a = self.b;
#         self.b = 4 * self.a + curr;
# 
#         Some(curr)
#     }
# }
</code></pre>
<p>This implementation runs in the order of nanoseconds.</p>
<p><img src="benchmarks/p002/report/pdf.svg" alt="PDF" /></p>
<p><a href="https://github.com/kwyse/euler-solutions/blob/master/src/p002.rs">Full source code</a></p>
<p><a href="benchmarks/p002/report/index.html">Benchmark report</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
